<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>–§–∏–ª–≤–æ—Ä–¥—ã</title>
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* CSS (–°—Ç–∏–ª–∏) */

        /* 1. –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç–µ–º */
        :root {
            --font-main: 'Manrope', sans-serif;
            --transition-speed: 0.3s;
            --transition-fast: 0.15s;

            /* –°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞ */
            --bg-light: #f5f6fa;
            --text-light: #4a4a4a;
            --card-light: #ffffff;
            --accent-light: #4870ff;
            --accent-hover-light: #3a59c9;
            --grid-border-light: #e1e4e8;
            --selected-light: #dbe4ff;
            --text-selected-light: #2c3e50;
            --shadow-light: 0 8px 30px rgba(60, 70, 80, 0.12);
            --hint-color-light: var(--accent-light);

            /* –¢—ë–º–Ω–∞—è —Ç–µ–º–∞ */
            --bg-dark: #1d1d1d;
            --text-dark: #e1e1e1;
            --card-dark: #2a2a2a;
            --accent-dark: #5d8aff;
            --accent-hover-dark: #7d9fff;
            --grid-border-dark: #3a3a3a;
            --selected-dark: #313b52;
            --text-selected-dark: #e1e1e1;
            --shadow-dark: 0 8px 30px rgba(0, 0, 0, 0.2);
            --hint-color-dark: var(--accent-dark);
        }

        body {
            font-family: var(--font-main);
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color var(--transition-speed), color var(--transition-speed);
            overflow: hidden;
            -webkit-tap-highlight-color: transparent; /* –£–±–∏—Ä–∞–µ—Ç —Å–∏–Ω—é—é –ø–æ–¥—Å–≤–µ—Ç–∫—É –ø—Ä–∏ —Ç–∞–ø–µ */
        }
        
        body[data-theme='light'] {
            --bg-color: var(--bg-light);
            --text-color: var(--text-light);
            --card-color: var(--card-light);
            --accent-color: var(--accent-light);
            --accent-hover-color: var(--accent-hover-light);
            --grid-border-color: var(--grid-border-light);
            --selected-color: var(--selected-light);
            --text-selected-color: var(--text-selected-light);
            --box-shadow: var(--shadow-light);
            --hint-color: var(--hint-color-light);
        }

        body[data-theme='dark'] {
            --bg-color: var(--bg-dark);
            --text-color: var(--text-dark);
            --card-color: var(--card-dark);
            --accent-color: var(--accent-dark);
            --accent-hover-color: var(--accent-hover-dark);
            --grid-border-color: var(--grid-border-dark);
            --selected-color: var(--selected-dark);
            --text-selected-color: var(--text-selected-dark);
            --box-shadow: var(--shadow-dark);
            --hint-color: var(--hint-color-dark);
        }

        /* 2. –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —ç–∫—Ä–∞–Ω–æ–≤ */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            box-sizing: border-box;
            opacity: 0;
            transform: scale(0.98);
            transition: opacity var(--transition-speed) ease, transform var(--transition-speed) ease;
            pointer-events: none;
        }

        .screen.active {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        /* 3. –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é */
        #main-menu .title {
            font-size: clamp(3rem, 12vw, 5rem);
            font-weight: 800;
            color: var(--accent-color);
            margin-bottom: 2rem;
        }

        .menu-grid {
            display: grid;
            grid-template-columns: 1fr; /* –ò–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ 1 –∫–æ–ª–æ–Ω–∫—É */
            gap: 1rem;
            width: 100%;
            max-width: 320px; /* –£–º–µ–Ω—å—à–µ–Ω–∞ —à–∏—Ä–∏–Ω–∞ –¥–ª—è –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –º–µ–Ω—é */
        }

        .menu-button {
            background-color: var(--card-color);
            color: var(--text-color);
            border: none;
            border-radius: 16px;
            padding: 1.2rem 1rem;
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: transform var(--transition-speed), box-shadow var(--transition-speed), background-color var(--transition-speed);
            box-shadow: var(--box-shadow);
            text-align: center;
        }

        .menu-button:hover {
            transform: translateY(-6px);
            box-shadow: 0 12px 35px rgba(60, 70, 80, 0.15);
        }
        
        body[data-theme='dark'] .menu-button:hover {
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.25);
        }

        .menu-button .level-info {
            font-size: 0.9rem;
            font-weight: 400;
            color: var(--text-color);
            opacity: 0.6;
            margin-top: 5px;
        }
        
        #theme-toggle {
            margin-top: 2rem;
            background-color: var(--card-color);
            border: 1px solid var(--grid-border-color);
            color: var(--text-color);
            padding: 0.8rem 1.5rem;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-speed);
        }
        
        #theme-toggle:hover {
             transform: translateY(-3px);
             box-shadow: var(--box-shadow);
        }
        

        /* 4. –ò–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω */
        #game-screen {
            justify-content: space-around;
        }

        .game-header {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 5px;
        }
        
        .game-header-button {
            background-color: var(--card-color);
            border: 1px solid var(--grid-border-color);
            color: var(--text-color);
            padding: 0.6rem 1.2rem;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-speed);
        }
        .game-header-button:hover {
            transform: translateY(-3px);
            box-shadow: var(--box-shadow);
            border-color: var(--accent-color);
        }
        
        .level-display {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-color);
        }

        #grid-container {
            display: grid;
            gap: 6px;
            width: 90vw;
            max-width: 500px;
            margin: 1rem auto;
            user-select: none;
        }

        .grid-cell {
            aspect-ratio: 1 / 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--card-color);
            border: 1px solid transparent;
            border-radius: 12px;
            font-size: clamp(1rem, 5vw, 2rem);
            font-weight: 700;
            text-transform: uppercase;
            color: var(--text-color);
            transition: background-color var(--transition-fast), color var(--transition-fast), transform var(--transition-fast), border-color var(--transition-fast), box-shadow var(--transition-fast);
            cursor: pointer;
        }
        
        .grid-cell.selected {
            background-color: var(--selected-color);
            color: var(--text-selected-color);
            transform: scale(0.9);
            border-color: var(--accent-color);
        }

        .grid-cell.found {
            transform: scale(1);
            color: #fff; /* –ë—É–¥–µ—Ç –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω–æ JS */
            box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.4); /* –ö–æ–Ω—Ç—É—Ä —Å–ª–æ–≤–∞ */
        }
        
        .grid-cell.hint {
            /* –ê–Ω–∏–º–∞—Ü–∏—è —Ç–µ–ø–µ—Ä—å –æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω–∞—è */
            animation: hint-pulse 1s ease-in-out;
        }

        @keyframes hint-pulse {
            0% { box-shadow: inset 0 0 0 0px var(--hint-color); }
            50% { box-shadow: inset 0 0 0 4px var(--hint-color); }
            100% { box-shadow: inset 0 0 0 0px var(--hint-color); }
        }

        /* 5. –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –ø–æ–±–µ–¥—ã */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-speed);
            z-index: 1000;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background-color: var(--card-color);
            padding: 2rem 2.5rem;
            border-radius: 20px;
            text-align: center;
            box-shadow: var(--box-shadow);
            transform: scale(0.8);
            transition: transform var(--transition-speed) ease-out;
            width: 90%;
            max-width: 380px;
        }

        .modal-overlay.active .modal-content {
            transform: scale(1);
        }
        
        .modal-content h2 {
            font-size: 2.2rem;
            font-weight: 800;
            color: var(--accent-color);
            margin-top: 0;
            margin-bottom: 0.5rem;
        }

        .modal-content p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.8;
        }

        .modal-button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 1rem 2.5rem;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition-speed);
            width: 100%;
        }

        .modal-button:hover {
            background-color: var(--accent-hover-color);
            transform: scale(1.05);
        }

    </style>
</head>
<body data-theme="light">

    <div id="app-container">
        
        <div id="main-menu" class="screen active">
            <h1 class="title">–§–∏–ª–≤–æ—Ä–¥—ã</h1>
            <div class="menu-grid">
                <button class="menu-button" data-size="5">5 x 5 <div class="level-info" id="level-info-5">–£—Ä–æ–≤–µ–Ω—å: 1</div></button>
                <button class="menu-button" data-size="6">6 x 6 <div class="level-info" id="level-info-6">–£—Ä–æ–≤–µ–Ω—å: 1</div></button>
                <button class="menu-button" data-size="7">7 x 7 <div class="level-info" id="level-info-7">–£—Ä–æ–≤–µ–Ω—å: 1</div></button>
                <button class="menu-button" data-size="8">8 x 8 <div class="level-info" id="level-info-8">–£—Ä–æ–≤–µ–Ω—å: 1</div></button>
            </div>
            <button id="theme-toggle">–°–º–µ–Ω–∏—Ç—å —Ç–µ–º—É</button>
        </div>

        <div id="game-screen" class="screen">
            <div class="game-header">
                <button class="game-header-button" id="back-button">–ú–µ–Ω—é</button>
                <div id="level-display" class="level-display">–£—Ä–æ–≤–µ–Ω—å 1</div>
                <button class="game-header-button" id="hint-button">üí°</button>
            </div>
            <div id="grid-container"></div>
            <div class="game-footer-placeholder"></div>
        </div>

    </div>

    <div id="win-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>–û—Ç–ª–∏—á–Ω–æ!</h2>
            <p>–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!</p>
            <button id="next-level-button" class="modal-button">–°–ª–µ–¥—É—é—â–∏–π</button>
        </div>
    </div>

    <script>
    // JavaScript (–õ–æ–≥–∏–∫–∞ –∏–≥—Ä—ã)
    document.addEventListener('DOMContentLoaded', async () => {

// === VK Integration ===
            const APP_ID = 53867134;
            const STATS_VK_KEY_PREFIX = 'ticTacToeStats';
            const STATS_LOCAL_KEY = 'ticTacToeLocalSave';

            let vkUser = null;
            let vkUserId = null;
            let vkAccessToken = null;
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è VK Bridge
        async function initVK() {
            try {
                await vkBridge.send('VKWebAppInit', {});
                
                // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
                const userInfo = await vkBridge.send('VKWebAppGetUserInfo');
                vkUser = userInfo;
                vkUserId = userInfo.id;
                
                // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω –¥–æ—Å—Ç—É–ø–∞
                const tokenData = await vkBridge.send('VKWebAppGetAuthToken', {
                    app_id: APP_ID,
                    scope: 'storage'
                });
                vkAccessToken = tokenData.access_token;
                
                // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                await loadStats();
                
                console.log('VK Bridge –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ VK Bridge:', error);
                // –ó–∞–≥—Ä—É–∂–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ, –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ VK
                loadLocalStats();
            }
        }
        await initVK();


        // 1. –ë–ê–ó–ê –°–õ–û–í (–º–æ–∂–Ω–æ –≤—Å—Ç–∞–≤–ª—è—Ç—å –≤ –ª—é–±–æ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ)
        const wordsDB = {
            4: ["–ö–û–§–ï", "–õ–ï–¢–û", "–ú–û–†–ï", "–ù–ï–ë–û", "–†–´–ë–ê", "–°–õ–û–ù", "–•–õ–ï–ë", "–¶–í–ï–¢", "–ß–ê–®–ê", "–Ø–î–†–û"],
            5: ["–ê–†–ë–£–ó", "–ë–ê–ù–ê–ù", "–í–ï–¢–ï–†", "–ì–û–†–û–î", "–î–í–ï–†–¨", "–ö–ù–ò–ì–ê", "–õ–ê–ú–ü–ê", "–ú–´–®–ö–ê", "–û–ì–û–ù–¨", "–ü–ï–°–ù–Ø"],
            6: ["–ê–ü–¢–ï–ö–ê", "–ì–ê–†–ê–ñ", "–î–û–†–û–ì–ê", "–ó–ê–î–ê–ß–ê", "–ö–ê–ú–ï–ù–¨", "–ö–û–°–ú–û–°", "–ú–ê–®–ò–ù–ê", "–ü–û–ë–ï–î–ê", "–°–û–õ–ù–¶–ï", "–¢–ï–ê–¢–†"],
            7: ["–ë–£–¢–´–õ–ö–ê", "–î–ï–†–ï–í–ù–Ø", "–ó–ê–í–¢–†–ê–ö", "–ó–ï–†–ö–ê–õ–û", "–ö–û–†–ê–ë–õ–¨", "–ú–ê–ì–ê–ó–ò–ù", "–ü–õ–ê–ù–ï–¢–ê", "–†–ê–î–û–°–¢–¨", "–¢–ï–õ–ï–§–û–ù", "–£–ß–ò–¢–ï–õ–¨"],
            8: ["–ê–í–¢–û–ë–£–°", "–í–û–î–û–ü–ê–î", "–ì–û–†–ò–ó–û–ù–¢", "–ö–ê–†–¢–û–®–ö–ê", "–ö–í–ê–†–¢–ò–†–ê", "–ú–û–õ–û–¢–û–ö", "–û–ö–ï–ê–ù", "–°–ê–ú–û–õ–ï–¢", "–ß–ï–ú–ü–ò–û–ù", "–®–û–ö–û–õ–ê–î"],
            9: ["–í–ò–ù–û–ì–†–ê–î", "–ò–ù–°–¢–†–£–ú–ï–ù–¢", "–ö–ê–õ–ï–ù–î–ê–†–¨", "–û–î–£–í–ê–ù–ß–ò–ö", "–ü–ò–†–ê–ú–ò–î–ê", "–ü–£–¢–ï–®–ï–°–¢–í–ò–ï", "–†–ï–°–¢–û–†–ê–ù", "–§–ï–°–¢–ò–í–ê–õ–¨"],
            10: ["–í–ï–õ–û–°–ò–ü–ï–î", "–í–û–û–ë–†–ê–ñ–ï–ù–ò–ï", "–ì–û–°–£–î–ê–†–°–¢–í–û", "–ó–ù–ê–ö–û–ú–°–¢–í–û", "–ò–°–ö–£–°–°–¢–í–û", "–ö–û–ú–ü–¨–Æ–¢–ï–†", "–õ–ò–¢–ï–†–ê–¢–£–†–ê", "–ú–ê–¢–ï–ú–ê–¢–ò–ö–ê"],
            11: ["–ê–í–¢–û–ú–û–ë–ò–õ–¨", "–ê–ü–õ–û–î–ò–°–ú–ï–ù–¢–´", "–ë–õ–ê–ì–û–î–ê–†–ù–û–°–¢–¨", "–í–î–û–•–ù–û–í–ï–ù–ò–ï", "–í–û–°–ü–û–ú–ò–ù–ê–ù–ò–ï", "–î–ò–°–¶–ò–ü–õ–ò–ù–ê", "–û–¢–í–ï–¢–°–¢–í–ï–ù–ù–û–°–¢–¨"],
            12: ["–ü–†–û–ì–†–ê–ú–ú–ò–†–û–í–ê–ù–ò–ï", "–î–û–°–¢–û–ü–†–ò–ú–ï–ß–ê–¢–ï–õ–¨–ù–û–°–¢–¨"]
        };
        
        const foundColors = [
            { bg: '#f39c12', text: '#ffffff' }, { bg: '#2ecc71', text: '#ffffff' },
            { bg: '#3498db', text: '#ffffff' }, { bg: '#9b59b6', text: '#ffffff' },
            { bg: '#e74c3c', text: '#ffffff' }, { bg: '#1abc9c', text: '#ffffff' },
            { bg: '#f1c40f', text: '#ffffff' }, { bg: '#27ae60', text: '#ffffff' },
            { bg: '#2980b9', text: '#ffffff' }, { bg: '#8e44ad', text: '#ffffff' }
        ]

        // 2. –°–û–°–¢–û–Ø–ù–ò–ï –ò–ì–†–´ –ò –≠–õ–ï–ú–ï–ù–¢–´ DOM
        const state = {
            gridSize: 0,
            currentLevel: 1,
            words: [],
            wordCellCoords: new Map(),
            grid: [],
            foundWords: [],
            isSelecting: false,
            selectedCells: [],
            hintedWord: null,
            hintedLetterIndex: 0,
        };
        
        const dom = {
            mainMenu: document.getElementById('main-menu'),
            gameScreen: document.getElementById('game-screen'),
            gridContainer: document.getElementById('grid-container'),
            levelDisplay: document.getElementById('level-display'),
            winModal: document.getElementById('win-modal'),
            themeToggle: document.getElementById('theme-toggle'),
            backButton: document.getElementById('back-button'),
            hintButton: document.getElementById('hint-button'),
            nextLevelButton: document.getElementById('next-level-button'),
        };

        // 3. –û–°–ù–û–í–ù–ê–Ø –õ–û–ì–ò–ö–ê
        
        const init = () => {
            setupEventListeners();
            loadTheme();
            updateMenuLevels();
        };

        const setupEventListeners = () => {
            document.querySelectorAll('.menu-button').forEach(button => {
                button.addEventListener('click', () => startGame(parseInt(button.dataset.size)));
            });
            dom.backButton.addEventListener('click', showMainMenu);
            dom.hintButton.addEventListener('click', handleHintClick);
            dom.nextLevelButton.addEventListener('click', nextLevel);
            dom.themeToggle.addEventListener('click', toggleTheme);
            
            // –ú—ã—à—å
            dom.gridContainer.addEventListener('mousedown', handleMouseDown);
            dom.gridContainer.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp); // –°–ª—É—à–∞—Ç–µ–ª—å –Ω–∞ –≤—Å–µ –æ–∫–Ω–æ
            
            // –°–µ–Ω—Å–æ—Ä–Ω—ã–π –≤–≤–æ–¥ (–ò–°–ü–†–ê–í–õ–ï–ù–û)
            dom.gridContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
            dom.gridContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
            window.addEventListener('touchend', handleTouchEnd); // –°–ª—É—à–∞—Ç–µ–ª—å –Ω–∞ –≤—Å–µ –æ–∫–Ω–æ
        };

        const startGame = (size) => {
            state.gridSize = size;
            loadProgress();
            showScreen('game-screen');
            generateLevel();
        };

        const nextLevel = () => {
            hideWinModal();
            state.currentLevel++;
            saveProgress();
            generateLevel();
        }

        const showMainMenu = () => {
            showScreen('main-menu');
            updateMenuLevels();
        };

        const showScreen = (screenId) => {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        };

        const generateLevel = () => {
            resetStateForNewLevel();
            dom.levelDisplay.textContent = `–£—Ä–æ–≤–µ–Ω—å ${state.currentLevel}`;
            
            const requiredArea = state.gridSize * state.gridSize;
            state.words = findWordCombination(requiredArea);
            
            if (!state.words) {
                alert("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–æ–±—Ä–∞—Ç—å —Å–ª–æ–≤–∞ –¥–ª—è –ø–æ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ —Å–ª–æ–≤ –≤ –±–∞–∑—É –∏–ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å —Ä–∞–∑–º–µ—Ä –ø–æ–ª—è.");
                showMainMenu();
                return;
            }

            let success = false;
            let attempts = 0;
            while(!success && attempts < 200) {
                state.grid = createEmptyGrid();
                state.wordCellCoords.clear();
                success = placeWordsOnGrid();
                attempts++;
            }

            if(!success) {
                alert("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —É—Ä–æ–≤–µ–Ω—å (—Å–ª–æ–≤–∞ –Ω–µ —Ä–∞–∑–º–µ—â–∞—é—Ç—Å—è). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.");
                showMainMenu();
                return;
            }
            renderGrid();
        };
        
        const resetStateForNewLevel = () => {
            state.foundWords = [];
            state.selectedCells = [];
            state.hintedWord = null;
            state.hintedLetterIndex = 0;
            dom.gridContainer.innerHTML = '';
        };

        // 4. –ì–ï–ù–ï–†–ê–¶–ò–Ø –ü–û–õ–Ø
        function findWordCombination(targetSum) {
            const allWords = Object.values(wordsDB).flat().map(w => w.toLowerCase());
            const uniqueWords = [...new Set(allWords)];
            uniqueWords.sort(() => Math.random() - 0.5);

            let result = null;

            function backtrack(startIndex, currentSum, combination) {
                if (result) return;
                if (currentSum === targetSum) {
                    result = [...combination];
                    return;
                }
                if (currentSum > targetSum || startIndex === uniqueWords.length) {
                    return;
                }

                const word = uniqueWords[startIndex];
                combination.push(word);
                backtrack(startIndex + 1, currentSum + word.length, combination);
                
                if (result) return;
                combination.pop();
                backtrack(startIndex + 1, currentSum, combination);
            }
            backtrack(0, 0, []);
            return result;
        }

        const createEmptyGrid = () => Array.from({ length: state.gridSize }, () => Array(state.gridSize).fill(null));

        const placeWordsOnGrid = () => {
            const sortedWords = [...state.words].sort((a, b) => b.length - a.length);
            for (const word of sortedWords) {
                let placed = false;
                const placementAttempts = 150;
                for (let i = 0; i < placementAttempts; i++) {
                    const path = findPathForWord(word.length);
                    if (path) {
                        state.wordCellCoords.set(word, path);
                        for (let j = 0; j < word.length; j++) {
                            const { r, c } = path[j];
                            state.grid[r][c] = word[j];
                        }
                        placed = true;
                        break;
                    }
                }
                if (!placed) return false;
            }
            return true;
        };
        
        const findPathForWord = (length) => {
            const startR = Math.floor(Math.random() * state.gridSize);
            const startC = Math.floor(Math.random() * state.gridSize);
            const path = [];

            function backtrack(r, c) {
                if (path.length === length) return true;
                if (r < 0 || r >= state.gridSize || c < 0 || c >= state.gridSize || state.grid[r][c] !== null) return false;
                
                path.push({ r, c });
                state.grid[r][c] = 'temp';
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]].sort(() => Math.random() - 0.5);
                
                for (const [dr, dc] of directions) {
                    if (backtrack(r + dr, c + dc)) {
                        state.grid[r][c] = null;
                        return true;
                    }
                }
                path.pop();
                state.grid[r][c] = null;
                return false;
            }
            return backtrack(startR, startC) ? path : null;
        };
        
        // 5. –†–ï–ù–î–ï–†–ò–ù–ì
        const renderGrid = () => {
            dom.gridContainer.innerHTML = '';
            dom.gridContainer.style.gridTemplateColumns = `repeat(${state.gridSize}, 1fr)`;
            state.grid.forEach((row, r) => {
                row.forEach((letter, c) => {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.textContent = letter;
                    dom.gridContainer.appendChild(cell);
                });
            });
        };
        
        const updateSelectionLook = () => {
             document.querySelectorAll('.grid-cell.selected').forEach(c => c.classList.remove('selected'));
             state.selectedCells.forEach(({r, c}) => {
                const cellEl = document.querySelector(`.grid-cell[data-r='${r}'][data-c='${c}']`);
                if(cellEl) cellEl.classList.add('selected');
             });
        };
        
        // 6. –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–Ø (–ò–°–ü–†–ê–í–õ–ï–ù–û –î–õ–Ø –°–ï–ù–°–û–†–ê)
        const getCellFromCoords = ({ clientX, clientY }) => {
            return document.elementFromPoint(clientX, clientY);
        }

        const startSelection = (target) => {
            const cell = target.closest('.grid-cell');
            if (cell && !cell.classList.contains('found')) {
                state.isSelecting = true;
                addCellToSelection(cell);
            }
        };

        const moveSelection = (target) => {
            if (!state.isSelecting) return;
            const cell = target.closest('.grid-cell');
            if (cell && !cell.classList.contains('found')) {
                addCellToSelection(cell);
            }
        };

        const endSelection = () => {
            if (state.isSelecting) {
                state.isSelecting = false;
                checkSelectedWord();
            }
        };

        // –ú—ã—à—å
        const handleMouseDown = (e) => startSelection(e.target);
        const handleMouseMove = (e) => moveSelection(e.target);
        const handleMouseUp = () => endSelection();

        // –¢–∞—á
        const handleTouchStart = (e) => {
            e.preventDefault();
            startSelection(getCellFromCoords(e.touches[0]));
        };
        const handleTouchMove = (e) => {
            e.preventDefault();
            moveSelection(getCellFromCoords(e.touches[0]));
        };
        const handleTouchEnd = () => endSelection();
        
        const addCellToSelection = (cellEl) => {
            const r = parseInt(cellEl.dataset.r);
            const c = parseInt(cellEl.dataset.c);
            
            if (state.selectedCells.some(cell => cell.r === r && cell.c === c)) return;

            const lastCell = state.selectedCells[state.selectedCells.length - 1];
            if (lastCell && Math.abs(lastCell.r - r) + Math.abs(lastCell.c - c) !== 1) return;

            state.selectedCells.push({r, c});
            updateSelectionLook();
        };

        const checkSelectedWord = () => {
            if (state.selectedCells.length === 0) return;
            let selectedWordStr = state.selectedCells.map(({r, c}) => state.grid[r][c]).join('');
            const wordData = state.words.find(w => w === selectedWordStr.toLowerCase());

            if (wordData && !state.foundWords.includes(wordData)) {
                if (wordData === state.hintedWord) clearHint();
                state.foundWords.push(wordData);
                markWordAsFound(wordData);
                if (state.foundWords.length === state.words.length) {
                    setTimeout(showWinModal, 500);
                }
            }
            
            state.selectedCells = [];
            updateSelectionLook();
        };
        
        const markWordAsFound = (word) => {
            const colorIndex = (state.foundWords.length - 1) % foundColors.length;
            const color = foundColors[colorIndex];
            const coords = state.wordCellCoords.get(word);
            
            coords.forEach(({r, c}) => {
                const cellEl = document.querySelector(`.grid-cell[data-r='${r}'][data-c='${c}']`);
                if (cellEl) {
                    cellEl.classList.add('found');
                    cellEl.style.backgroundColor = color.bg;
                    cellEl.style.color = color.text;
                }
            });
        };
        
        // 7. –°–ò–°–¢–ï–ú–ê –ü–û–î–°–ö–ê–ó–û–ö (–ò–°–ü–†–ê–í–õ–ï–ù–ê –ê–ù–ò–ú–ê–¶–ò–Ø)
        const handleHintClick = () => {
            if (!state.hintedWord) {
                const unfoundWords = state.words.filter(w => !state.foundWords.includes(w));
                if (unfoundWords.length === 0) return;
                state.hintedWord = unfoundWords[Math.floor(Math.random() * unfoundWords.length)];
                state.hintedLetterIndex = 0;
            }
            
            if (state.hintedLetterIndex >= state.hintedWord.length) return;
            state.hintedLetterIndex++;
            
            const coords = state.wordCellCoords.get(state.hintedWord);
            const cellsToAnimate = [];
            for (let i = 0; i < state.hintedLetterIndex; i++) {
                const { r, c } = coords[i];
                const cellEl = document.querySelector(`.grid-cell[data-r='${r}'][data-c='${c}']`);
                if (cellEl) cellsToAnimate.push(cellEl);
            }
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
            document.querySelectorAll('.grid-cell.hint').forEach(cell => cell.classList.remove('hint'));
            
            setTimeout(() => {
                cellsToAnimate.forEach(cell => cell.classList.add('hint'));
            }, 10);
        };
        
        const clearHint = () => {
            state.hintedWord = null;
            state.hintedLetterIndex = 0;
            document.querySelectorAll('.grid-cell.hint').forEach(cell => cell.classList.remove('hint'));
        };

        // 8. –£–ü–†–ê–í–õ–ï–ù–ò–ï UI –ò –°–û–•–†–ê–ù–ï–ù–ò–ï
        const showWinModal = () => dom.winModal.classList.add('active');
        const hideWinModal = () => dom.winModal.classList.remove('active');

        const saveProgress = () => {
            localStorage.setItem(`fillword_level_${state.gridSize}`, state.currentLevel);
        };

        const loadProgress = () => {
            const savedLevel = localStorage.getItem(`fillword_level_${state.gridSize}`);
            state.currentLevel = savedLevel ? parseInt(savedLevel) : 1;
        };

        const updateMenuLevels = () => {
            document.querySelectorAll('.menu-button').forEach(button => {
                const size = button.dataset.size;
                const level = localStorage.getItem(`fillword_level_${size}`) || 1;
                button.querySelector('.level-info').textContent = `–£—Ä–æ–≤–µ–Ω—å: ${level}`;
            });
        };

        const toggleTheme = () => {
            const newTheme = document.body.dataset.theme === 'light' ? 'dark' : 'light';
            document.body.dataset.theme = newTheme;
            localStorage.setItem('fillword_theme', newTheme);
        };

        const loadTheme = () => {
            const savedTheme = localStorage.getItem('fillword_theme') || 'light';
            document.body.dataset.theme = savedTheme;
        };
        
        // –ó–ê–ü–£–°–ö –ò–ì–†–´
        init();
    });
    </script>
</body>
</html>
